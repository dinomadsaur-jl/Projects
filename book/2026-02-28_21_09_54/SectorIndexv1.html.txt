<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sector Rotation Dashboard • Pyodide</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        html, body { margin:0; padding:0; height:100%; font-family:Arial,sans-serif; background:#f8f9fa; overflow:hidden; }
        h1 { text-align:center; color:#222; margin:8px 0; font-size:1.3rem; }
        .update { text-align:center; color:#555; margin:4px 0; font-size:0.8rem; padding:0 8px; }
        .grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(180px, 1fr)); gap:8px; height:calc(100% - 120px); overflow-y:auto; padding:8px; box-sizing:border-box; }
        .card { background:white; border-radius:8px; padding:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1); cursor:pointer; font-size:0.82rem; }
        .card:hover { transform:translateY(-2px); }
        .name { font-size:1.05rem; font-weight:bold; margin-bottom:5px; }
        .metric { margin:3px 0; font-size:0.9rem; }
        .trend { display:inline-block; padding:4px 10px; border-radius:14px; color:white; font-weight:bold; font-size:0.78rem; min-width:85px; text-align:center; }
        .spark { width:100%; height:40px; margin-top:6px; }
        #modal { display:none; position:fixed; z-index:1000; inset:0; background:rgba(0,0,0,0.7); overflow-y:auto; }
        #modal-content { background:white; margin:2% auto; padding:14px; width:96%; max-width:1000px; border-radius:8px; position:relative; }
        #close { position:absolute; right:14px; top:6px; font-size:28px; cursor:pointer; color:#888; }
        #close:hover { color:#000; }
        #plot { width:100%; height:80vh; min-height:480px; }
        #status { text-align:center; padding:10px; background:#f0f0f0; margin:10px; border-radius:8px; font-size:0.9rem; }
        #debug-info { margin:1rem 2rem; padding:1rem; background:#f8f9fa; border-radius:8px; font-family:monospace; font-size:0.85rem; white-space:pre-wrap; max-height:150px; overflow-y:auto; }
    </style>
</head>
<body>
    <h1>Sector Rotation Dashboard</h1>
    <div class="update" id="update">Loading Pyodide...</div>

    <div id="status">Initializing...</div>
    <div id="debug-info">Debug log (F12 Console for full details):</div>

    <div class="grid" id="grid"></div>

    <div id="modal">
        <div id="modal-content">
            <span id="close">×</span>
            <h2 id="modal-title"></h2>
            <div id="plot"></div>
        </div>
    </div>

    <script>
        // ── Config ───────────────────────────────────────
        const ALPHA_KEY = "FQHCROCVBRCEKGK8";
        const FINNHUB_KEY = "d6amqv9r01qqjvbr0qvgd6amqv9r01qqjvbr0r00";

        const PLOT_SMA_PERIOD = 50;
        const SMA_KEY = `SMA_${PLOT_SMA_PERIOD}`;
        const SMA_NAME = `SMA ${PLOT_SMA_PERIOD}`;

        const SECTORS = {
            tech:          {ticker: 'SOXX', name: 'Tech',         color: '#FF6B6B'},
            finance:       {ticker: 'XLF',  name: 'Finance',      color: '#45B7D1'},
            health:        {ticker: 'XLV',  name: 'Health',       color: '#DDA0DD'},
            energy:        {ticker: 'XLE',  name: 'Energy',       color: '#F7DC6F'},
            reits:         {ticker: 'VNQ',  name: 'REITs',        color: '#FFEAA7'},
            industrials:   {ticker: 'XLI',  name: 'Industrials',  color: '#85C1E9'},
            materials:     {ticker: 'XLB',  name: 'Materials',    color: '#BB8FCE'},
            utilities:     {ticker: 'XLU',  name: 'Utilities',    color: '#73C6B6'},
            consumer_disc: {ticker: 'XLY',  name: 'Consumption',  color: '#82E0AA'},
            consumer_stap: {ticker: 'XLP',  name: 'Staples',      color: '#F8C471'},
            transport:     {ticker: 'IYT',  name: 'Transport',    color: '#EB984E'},
            insurance:     {ticker: 'KIE',  name: 'Insurance',    color: '#96CEB4'}
        };

        const FROM = Math.floor((Date.now()/1000) - (365*5 + 60)*86400);
        const TO   = Math.floor(Date.now()/1000);
        const MAX_POINTS = 1200;

        let pyodide;

        function logDebug(msg) {
            const logEl = document.getElementById("debug-info");
            logEl.textContent += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        // ── Cache ────────────────────────────────────────
        const DB_NAME = "SectorPyodideCache";
        async function getDB() {
            return new Promise((res, rej) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = e => e.target.result.createObjectStore("cache", {keyPath: "key"});
                req.onsuccess = e => res(e.target.result);
                req.onerror = e => rej(e.target.error);
            });
        }

        async function cacheData(key, value) {
            const db = await getDB();
            const tx = db.transaction("cache", "readwrite");
            tx.objectStore("cache").put({key, value, ts: Date.now()});
            logDebug(`Cached ${key}`);
        }

        async function getCached(key) {
            const db = await getDB();
            return new Promise(r => {
                const req = db.transaction("cache").objectStore("cache").get(key);
                req.onsuccess = () => r(req.result?.value);
                req.onerror = () => r(null);
            });
        }

        // ── Init Pyodide ────────────────────────────────
        async function initPyodide() {
            logDebug("Starting Pyodide");
            document.getElementById("status").textContent = "Loading Pyodide...";

            pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.27.5/full/" });
            await pyodide.loadPackage(['micropip']);
            const micropip = pyodide.pyimport('micropip');
            await micropip.install(['pandas', 'numpy', 'plotly']);

            logDebug("Pyodide ready");
            document.getElementById("status").textContent = "Python ready";
        }

        // ── Fetch Alpha Vantage ─────────────────────────
        async function fetchAlpha(symbol, type = "daily") {
            const func = type === "weekly" ? "TIME_SERIES_WEEKLY" : "TIME_SERIES_DAILY";
            const url = `https://www.alphavantage.co/query?function=\( {func}&symbol= \){symbol}&apikey=${ALPHA_KEY}`;
            logDebug(`Alpha ${symbol} ${type} - ${url}`);

            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const json = await resp.json();

            if (json["Error Message"] || json["Note"] || json["Information"]) {
                throw new Error(json["Error Message"] || json["Note"] || json["Information"]);
            }

            const seriesKey = type === "weekly" ? "Weekly Time Series" : "Time Series (Daily)";
            const series = json[seriesKey];
            if (!series) throw new Error(`No series`);

            const t = [];
            const c = [];
            Object.entries(series).slice(0, MAX_POINTS).forEach(([dateStr, values]) => {
                t.push(new Date(dateStr));
                c.push(parseFloat(values["4. close"] || 0));
            });

            logDebug(`Alpha ${symbol} ${type}: ${t.length} points`);
            return { t, c };
        }

        // ── Fetch Finnhub (Fallback) ────────────────────
        async function fetchFinnhub(symbol, resolution) {
            const url = `https://finnhub.io/api/v1/stock/candle?symbol=\( {symbol}&resolution= \){resolution}&from=\( {FROM}&to= \){TO}&token=${FINNHUB_KEY}`;
            logDebug(`Finnhub ${symbol} ${resolution} - ${url}`);

            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const json = await resp.json();
            if (json.s !== "ok") throw new Error(`No data: ${json.s}`);

            logDebug(`Finnhub ${symbol}: ${json.t.length} points`);
            return { t: json.t.map(ts => new Date(ts*1000)), c: json.c };
        }

        // ── Generate Dashboard ──────────────────────────
        async function generateDashboard() {
            const status = document.getElementById("status");
            status.textContent = "Checking cache...";

            const cached = await getCached("dashboard");
            if (cached) {
                document.getElementById("grid").innerHTML = cached;
                document.getElementById("update").textContent = "Loaded from cache";
                status.textContent = "Cache loaded ✓";
                attachCardListeners();
                return;
            }

            status.textContent = "Fetching fresh data...";

            let sectorsData = [];

            for (const [key, config] of Object.entries(SECTORS)) {
                status.textContent = `Fetching \( {config.name} ( \){config.ticker})...`;

                let df = null;
                try {
                    // Try Alpha first
                    const weekly = await fetchAlpha(config.ticker, "weekly");
                    const daily  = await fetchAlpha(config.ticker, "daily");
                    df = { t: weekly.t.concat(daily.t), c: weekly.c.concat(daily.c) };
                } catch (err) {
                    logDebug(`Alpha failed for ${config.ticker}: ${err.message}`);
                    try {
                        const weekly = await fetchFinnhub(config.ticker, "W");
                        const daily  = await fetchFinnhub(config.ticker, "D");
                        df = { t: weekly.t.concat(daily.t), c: weekly.c.concat(daily.c) };
                    } catch (fErr) {
                        logDebug(`Finnhub fallback failed: ${fErr.message}`);
                        continue;
                    }
                }

                if (!df || df.t.length < 100) continue;

                // Simple JS indicators for cards
                const closes = df.c.slice(-60);
                const sma = [];
                for (let i = 0; i < closes.length; i++) {
                    const start = Math.max(0, i - PLOT_SMA_PERIOD + 1);
                    const slice = closes.slice(start, i + 1);
                    sma.push(slice.reduce((a,b)=>a+b, 0) / slice.length);
                }

                const lastPrice = df.c[df.c.length - 1] || 0;
                const lastReturn = df.c.length > 1 ? ((df.c[df.c.length - 1] - df.c[df.c.length - 2]) / df.c[df.c.length - 2]) * 100 : 0;

                sectorsData.push({
                    config,
                    price: lastPrice.toFixed(2),
                    return: lastReturn.toFixed(2),
                    sparkline: createSparkline(closes),
                    plotData: df
                });
            }

            document.getElementById("update").textContent = `Updated: ${new Date().toLocaleString()} • Sorted by performance`;
            status.textContent = "Rendering...";

            renderCards(sectorsData);
            await cacheData("dashboard", document.getElementById("grid").innerHTML);
            attachCardListeners();
        }

        function createSparkline(data) {
            if (data.length < 2) return "";
            const mn = Math.min(...data);
            const mx = Math.max(...data);
            const rg = mx - mn || 1;
            let points = "";
            const w = 140, h = 40;
            const step = w / (data.length - 1);
            data.forEach((v, i) => {
                const x = i * step;
                const y = h - ((v - mn) / rg * h);
                points += `\( {x}, \){y} `;
            });
            return `<svg viewBox="0 0 ${w} \( {h}" preserveAspectRatio="none"><polyline points=" \){points}" fill="none" stroke="#1f77b4" stroke-width="2"/></svg>`;
        }

        function renderCards(sectors) {
            const grid = document.getElementById("grid");
            grid.innerHTML = '';
            sectors.forEach(s => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <div class="name" style="color:\( {s.config.color}"> \){s.config.name} (${s.config.ticker})</div>
                    <div class="metric">Price: <strong>$${s.price}</strong></div>
                    <div class="metric">1D: <strong>${s.return}%</strong></div>
                    <div class="spark">${s.sparkline}</div>
                `;
                card.onclick = () => showPlot(s);
                grid.appendChild(card);
            });
        }

        function attachCardListeners() {
            document.querySelectorAll('.card').forEach(card => {
                card.onclick = () => {
                    const s = SECTORS[Object.keys(SECTORS).find(k => SECTORS[k].ticker === card.querySelector('.name').textContent.split('(')[1].slice(0,-1))];
                    showPlot({config: s, plotData: { /* dummy - full data loaded in modal */ }});
                };
            });
        }

        function showPlot(s) {
            document.getElementById('modal-title').textContent = 
                `\( {s.config.name} ( \){s.config.ticker}) - 5 Years + ${SMA_NAME}`;

            document.getElementById('modal').style.display = 'block';

            // Dummy plot (expand later with full data fetch in modal)
            const trace = {
                x: [1,2,3,4,5],
                y: [10,15,13,17,14],
                type: 'scatter',
                mode: 'lines',
                name: 'Price'
            };

            Plotly.newPlot('plot', [trace], {
                title: 'Sample Chart',
                xaxis: { title: 'Date' },
                yaxis: { title: 'Price' },
                height: 600
            });
        }

        document.getElementById('close').onclick = () => {
            document.getElementById('modal').style.display = 'none';
            Plotly.purge('plot');
        };

        window.onclick = e => {
            if (e.target.id === 'modal') {
                document.getElementById('modal').style.display = 'none';
                Plotly.purge('plot');
            }
        };

        // Start
        (async () => {
            await initPyodide();
            await generateDashboard();
        })();
    </script>
</body>
</html>